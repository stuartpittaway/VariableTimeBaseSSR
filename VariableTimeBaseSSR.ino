/*
Latest version found at https://github.com/stuartpittaway/VariableTimeBaseSSR
 
 
 Burst Fire Variable Time Base SSR controller (for Arduino)
 
 
 Note that this code ignores the zero cross delay/miss fire of the SSR !!!
 
 
 A SSR power controller with a "variable time base" changes the time base according to the power requirement. Burst ﬁring with a variable time base usesthe
 smallest possible number of AC cycles to deliver the required percentage power to the heater. 
 
 
 Why is variable time base preferred over a ﬁxed time base? 
 The ON/ OFF switching of the heater happens much more quickly with variable time base. The more quickly the heater is switched, the less temperature variations 
 the resistance element has. The nearly constant load current to the heater keeps the heater’s resistance element temperature nearly constant. 
 This provides a longer heater life.
 
 LICENCE
 Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)
 http://creativecommons.org/licenses/by-nc-sa/3.0/
 You are free:
 to Share — to copy, distribute and transmit the work
 to Remix — to adapt the work
 Under the following conditions:
 Attribution — You must attribute the work in the manner specified by the author or licensor (but not in any way that suggests that they endorse you or your use of the work).
 Noncommercial — You may not use this work for commercial purposes.
 Share Alike — If you alter, transform, or build upon this work, you may distribute the resulting work only under the same or similar license to this one.
 
 All code is copyright Stuart Pittaway, (c)2012.
 */


unsigned int max_load_power = 3300;  //Maximum watts of power for the load (eg. 3kw water heater)

#define relay_pin A1
#define led_pin 6

//#define halfcyclems 1000/50/2    //1000ms / 50hz / half

#define ssr_on digitalWrite(relay_pin,HIGH);digitalWrite(led_pin,LOW);
#define ssr_off digitalWrite(relay_pin,LOW);digitalWrite(led_pin,HIGH);

//This table is an attempt to provide a variable time base to fire the SSR device rather than a straight on/off delay (fixed time base)
//Cycle over 100 bits/mains half cycles, 101 items in the array from 0% to 100% power
uint8_t PROGMEM bitmaptable[][13] ={
{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0},  //OFF 0%
{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10},
{0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x10},
{0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x20},
{0x0,0x0,0x0,0x80,0x0,0x0,0x40,0x0,0x0,0x20,0x0,0x0,0x10},
{0x0,0x0,0x10,0x0,0x1,0x0,0x0,0x10,0x0,0x1,0x0,0x0,0x10},
{0x0,0x1,0x0,0x0,0x80,0x0,0x40,0x0,0x40,0x0,0x20,0x0,0x10},
{0x0,0x4,0x0,0x10,0x0,0x40,0x0,0x80,0x2,0x0,0x8,0x0,0x10},
{0x0,0x10,0x1,0x0,0x8,0x0,0x80,0x4,0x0,0x40,0x2,0x0,0x20},
{0x0,0x20,0x4,0x0,0x80,0x10,0x2,0x0,0x40,0x8,0x1,0x0,0x20},
//10%
{0x0,0x40,0x10,0x4,0x1,0x0,0x40,0x10,0x4,0x1,0x0,0x40,0x10},
{0x0,0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x1,0x0,0x80,0x40,0x20},
{0x1,0x1,0x1,0x0,0x80,0x80,0x80,0x40,0x40,0x40,0x20,0x20,0x20},
{0x2,0x2,0x2,0x4,0x4,0x4,0x8,0x8,0x8,0x10,0x10,0x10,0x20},
{0x2,0x4,0x8,0x10,0x20,0x40,0x80,0x81,0x2,0x4,0x8,0x10,0x20},
{0x4,0x8,0x10,0x40,0x81,0x4,0x8,0x10,0x40,0x81,0x4,0x8,0x10},
{0x4,0x10,0x41,0x2,0x8,0x20,0x81,0x4,0x10,0x40,0x82,0x8,0x20},
{0x8,0x20,0x82,0x8,0x20,0x82,0x10,0x41,0x4,0x10,0x41,0x4,0x20},
{0x8,0x21,0x4,0x20,0x84,0x10,0x82,0x8,0x41,0x8,0x21,0x4,0x20},
{0x8,0x42,0x8,0x42,0x10,0x42,0x10,0x82,0x10,0x84,0x10,0x84,0x20},
//20%
{0x8,0x42,0x10,0x84,0x21,0x8,0x42,0x10,0x84,0x21,0x8,0x42,0x10},
{0x10,0x84,0x22,0x10,0x84,0x42,0x10,0x88,0x42,0x11,0x8,0x42,0x20},
{0x10,0x88,0x44,0x22,0x11,0x8,0x84,0x22,0x11,0x8,0x84,0x42,0x20},
{0x11,0x8,0x88,0x44,0x42,0x22,0x11,0x10,0x88,0x84,0x44,0x22,0x20},
{0x11,0x11,0x11,0x8,0x88,0x88,0x84,0x44,0x44,0x42,0x22,0x22,0x20},
{0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10},
{0x22,0x22,0x22,0x44,0x44,0x44,0x88,0x88,0x88,0x91,0x11,0x11,0x20},
{0x22,0x24,0x44,0x88,0x89,0x11,0x22,0x24,0x44,0x48,0x89,0x11,0x20},
{0x22,0x44,0x89,0x11,0x22,0x44,0x88,0x91,0x22,0x44,0x48,0x91,0x20},
{0x24,0x48,0x91,0x22,0x48,0x91,0x22,0x44,0x91,0x22,0x44,0x89,0x20},
{0x24,0x89,0x22,0x48,0x92,0x24,0x89,0x22,0x48,0x92,0x24,0x89,0x20},
{0x24,0x91,0x24,0x89,0x24,0x89,0x24,0x49,0x24,0x49,0x22,0x49,0x20},
{0x24,0x92,0x49,0x12,0x49,0x24,0x89,0x24,0x92,0x44,0x92,0x49,0x20},
{0x24,0x92,0x49,0x24,0x92,0x49,0x24,0x92,0x49,0x24,0x92,0x49,0x20},
{0x49,0x24,0x92,0x49,0x24,0x92,0x52,0x49,0x24,0x92,0x49,0x24,0x90},
{0x49,0x24,0x94,0x92,0x49,0x49,0x24,0x94,0x92,0x49,0x49,0x24,0x90},
{0x49,0x29,0x25,0x24,0x94,0x92,0x92,0x4a,0x49,0x49,0x25,0x24,0xa0},
{0x49,0x49,0x49,0x29,0x29,0x29,0x25,0x25,0x25,0x24,0xa4,0xa4,0xa0},
{0x4a,0x4a,0x4a,0x52,0x52,0x52,0x92,0x92,0x92,0x94,0x94,0x94,0xa0},
{0x4a,0x52,0x92,0x94,0xa4,0xa5,0x29,0x49,0x4a,0x52,0x52,0x94,0xa0},
{0x52,0x94,0xa5,0x29,0x4a,0x52,0x94,0xa5,0x29,0x4a,0x52,0x94,0xa0},
{0x52,0x94,0xa9,0x4a,0x52,0xa5,0x29,0x52,0x94,0xa5,0x4a,0x52,0xa0},
{0x52,0xa5,0x2a,0x54,0xa5,0x4a,0x94,0xa9,0x4a,0x95,0x29,0x52,0xa0},
{0x54,0xa9,0x52,0xa5,0x4a,0x95,0x2a,0x54,0xa9,0x52,0xa5,0x4a,0x90},
{0x54,0xaa,0x55,0x2a,0x55,0x2a,0x95,0x2a,0x95,0x4a,0x95,0x4a,0xa0},
{0x55,0x2a,0x95,0x52,0xa9,0x55,0x2a,0x95,0x52,0xa9,0x55,0x2a,0x90},
{0x55,0x4a,0xaa,0x55,0x52,0xaa,0x95,0x52,0xaa,0x95,0x54,0xaa,0xa0},
{0x55,0x54,0xaa,0xaa,0x55,0x55,0x2a,0xaa,0x95,0x55,0x4a,0xaa,0xa0},
{0x55,0x55,0x55,0x2a,0xaa,0xaa,0x95,0x55,0x55,0x4a,0xaa,0xaa,0xa0},
{0x55,0x55,0x55,0x55,0x55,0x55,0x2a,0xaa,0xaa,0xaa,0xaa,0xaa,0x90},

{0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x50},  //50% 01010101

{0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xd5,0x55,0x55,0x55,0x55,0x55,0x60},
{0xaa,0xaa,0xaa,0xd5,0x55,0x55,0x6a,0xaa,0xaa,0xb5,0x55,0x55,0x50},
{0xaa,0xab,0x55,0x55,0xaa,0xaa,0xd5,0x55,0x6a,0xaa,0xb5,0x55,0x50},
{0xaa,0xb5,0x55,0xaa,0xad,0x55,0x6a,0xad,0x55,0x6a,0xab,0x55,0x50},
{0xaa,0xd5,0x6a,0xad,0x56,0xaa,0xd5,0x6a,0xad,0x56,0xaa,0xd5,0x60},
{0xab,0x55,0xaa,0xd5,0xaa,0xd5,0x6a,0xd5,0x6a,0xb5,0x6a,0xb5,0x50},
{0xab,0x56,0xad,0x5a,0xb5,0x6a,0xd5,0xab,0x56,0xad,0x5a,0xb5,0x60},
{0xad,0x5a,0xd5,0xab,0x5a,0xb5,0x6b,0x56,0xb5,0x6a,0xd6,0xad,0x50},
{0xad,0x6b,0x56,0xb5,0xad,0x5a,0xd6,0xad,0x6b,0x5a,0xb5,0xad,0x50},
{0xad,0x6b,0x5a,0xd6,0xb5,0xad,0x6b,0x5a,0xd6,0xb5,0xad,0x6b,0x50},
{0xb5,0xad,0x6d,0x6b,0x5b,0x5a,0xd6,0xb6,0xb5,0xad,0xad,0x6b,0x50},
{0xb5,0xb5,0xb5,0xad,0xad,0xad,0x6d,0x6d,0x6d,0x6b,0x6b,0x6b,0x50},
{0xb6,0xb6,0xb6,0xd6,0xd6,0xd6,0xda,0xda,0xda,0xdb,0x5b,0x5b,0x50},
{0xb6,0xd6,0xda,0xdb,0x6b,0x6d,0x6d,0xb5,0xb6,0xb6,0xda,0xdb,0x50},
{0xb6,0xdb,0x6b,0x6d,0xb6,0xb6,0xdb,0x6b,0x6d,0xb6,0xb6,0xdb,0x60},
{0xb6,0xdb,0x6d,0xb6,0xdb,0x6d,0xad,0xb6,0xdb,0x6d,0xb6,0xdb,0x60},
{0xdb,0x6d,0xb6,0xdb,0x6d,0xb6,0xdb,0x6d,0xb6,0xdb,0x6d,0xb6,0xd0},
{0xdb,0x6d,0xb6,0xed,0xb6,0xdb,0x76,0xdb,0x6d,0xbb,0x6d,0xb6,0xd0},
{0xdb,0x6e,0xdb,0x76,0xdb,0x76,0xdb,0xb6,0xdb,0xb6,0xdd,0xb6,0xd0},
{0xdb,0x76,0xdd,0xb7,0x6d,0xdb,0x76,0xdd,0xb7,0x6d,0xdb,0x76,0xd0},
{0xdb,0xb7,0x6e,0xdd,0xb7,0x6e,0xdd,0xbb,0x6e,0xdd,0xbb,0x76,0xd0},
{0xdd,0xbb,0x76,0xee,0xdd,0xbb,0x77,0x6e,0xdd,0xbb,0xb7,0x6e,0xd0},
{0xdd,0xdb,0xbb,0x77,0x76,0xee,0xdd,0xdb,0xbb,0xb7,0x76,0xee,0xd0},
{0xdd,0xdd,0xdd,0xbb,0xbb,0xbb,0x77,0x77,0x77,0x6e,0xee,0xee,0xd0},
{0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xe0},
{0xee,0xee,0xee,0xf7,0x77,0x77,0x7b,0xbb,0xbb,0xbd,0xdd,0xdd,0xd0},
{0xee,0xf7,0x77,0xbb,0xbd,0xdd,0xee,0xef,0x77,0x7b,0xbb,0xdd,0xd0},
{0xef,0x77,0xbb,0xdd,0xee,0xf7,0x7b,0xdd,0xee,0xf7,0x7b,0xbd,0xd0},
{0xef,0x7b,0xdd,0xef,0x7b,0xbd,0xef,0x77,0xbd,0xee,0xf7,0xbd,0xd0},
{0xf7,0xbd,0xef,0x7b,0xde,0xf7,0xbd,0xef,0x7b,0xde,0xf7,0xbd,0xe0},
{0xf7,0xbd,0xf7,0xbd,0xef,0xbd,0xef,0x7d,0xef,0x7b,0xef,0x7b,0xd0},
{0xf7,0xde,0xfb,0xdf,0x7b,0xef,0x7d,0xf7,0xbe,0xf7,0xde,0xfb,0xd0},
{0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xd0},
{0xfb,0xef,0xbe,0xfd,0xf7,0xdf,0x7e,0xfb,0xef,0xbf,0x7d,0xf7,0xd0},
{0xfb,0xf7,0xef,0xbf,0x7e,0xfb,0xf7,0xef,0xbf,0x7e,0xfb,0xf7,0xe0},
{0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0x7e,0xfd,0xfb,0xf7,0xef,0xd0},
{0xfd,0xfd,0xfd,0xfb,0xfb,0xfb,0xf7,0xf7,0xf7,0xef,0xef,0xef,0xd0},
{0xfe,0xfe,0xfe,0xff,0x7f,0x7f,0x7f,0xbf,0xbf,0xbf,0xdf,0xdf,0xd0},
{0xff,0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe,0xff,0x7f,0xbf,0xd0},
{0xff,0xbf,0xef,0xfb,0xfe,0xff,0xbf,0xef,0xfb,0xfe,0xff,0xbf,0xe0},
{0xff,0xdf,0xfb,0xff,0x7f,0xef,0xfd,0xff,0xbf,0xf7,0xfe,0xff,0xd0},
{0xff,0xef,0xfe,0xff,0xf7,0xff,0x7f,0xfb,0xff,0xbf,0xfd,0xff,0xd0},
{0xff,0xfb,0xff,0xef,0xff,0xbf,0xff,0x7f,0xfd,0xff,0xf7,0xff,0xe0},
{0xff,0xfe,0xff,0xff,0x7f,0xff,0xbf,0xff,0xbf,0xff,0xdf,0xff,0xe0},
{0xff,0xff,0xef,0xff,0xfe,0xff,0xff,0xef,0xff,0xfe,0xff,0xff,0xe0},
{0xff,0xff,0xff,0x7f,0xff,0xff,0xbf,0xff,0xff,0xdf,0xff,0xff,0xe0},
{0xff,0xff,0xff,0xff,0x7f,0xff,0xff,0xff,0xbf,0xff,0xff,0xff,0xd0},
{0xff,0xff,0xff,0xff,0xff,0xff,0xbf,0xff,0xff,0xff,0xff,0xff,0xe0},
{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0},
{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0} //FULL ON 100%
};

volatile unsigned long lastinterruptmillis=0;
volatile unsigned long millisecondsfor100ZC=0;  //Timing for 100 zero crosses
volatile uint8_t percentage=0;
volatile uint8_t stepindex=0;
volatile unsigned int interruptcounter=0;
volatile uint8_t oncounter=0;
volatile uint8_t calculatedpercentage=0;


void setup()
{
  Serial.begin(115200);          //Serial port for debugging output

  pinMode(relay_pin, OUTPUT);
  pinMode(led_pin, OUTPUT);

  ssr_off;

  digitalWrite(led_pin,HIGH);  //Nanode, switch LED off!  

  //PIN 3
  pinMode(3, INPUT);
  attachInterrupt(1, zerocrossing, RISING );

  Serial.println(F("Press letters u to increase power (up), d to decrease power level (down),  0 = off, 5= 50%, 1=100%"));
}

void loop()
{ 
  int sampleloop=10;
  
  while (1) {  
    if (sampleloop>0) {
    Serial.print(calculatedpercentage);
    Serial.print("% (");  
    
    Serial.print(max_load_power/100*calculatedpercentage);
    Serial.print("W) ");  
    Serial.print( (float)100000/(float)(millisecondsfor100ZC*2));
    Serial.println("Hz");
    sampleloop--;
    }

    delay(500);

    if (Serial.available())
    {
      unsigned char c = Serial.read();
      
      if (c=='u') {
        if (percentage<100) {
        percentage++;
        setPercentage(percentage);
        }
      }

      if (c=='d') {
        if (percentage>0) {
        percentage--;
        setPercentage(percentage);
        }
      }

      if (c=='0') {
        percentage=0;
        setPercentage(percentage);
      }

      if (c=='1') {
        percentage=100;
        setPercentage(percentage);
      }
      if (c=='5') {
        percentage=50;
        setPercentage(percentage);
      }

        sampleloop=10;     
    }
  }
}

void zerocrossing()
{
  if (interruptcounter==0) {
    lastinterruptmillis=millis();
  }
  
  interruptcounter++;

  if (interruptcounter==101) {
    millisecondsfor100ZC=millis()-lastinterruptmillis;
    interruptcounter=0;
  }

  uint8_t value=getBit(percentage,stepindex++);
  if (stepindex>100) {
    calculatedpercentage=oncounter;
    stepindex=0;
    oncounter=0;
  }

  if (value==1) {
    ssr_on;
    oncounter++;
  } 
  else {
    ssr_off;
  }
}

uint8_t getBit(int percentage,int location) { 
  //Get the nearest byte
  uint8_t value=pgm_read_byte(&(bitmaptable[percentage][location / 8]));
  uint8_t shift=(7-(location % 8));

  //Extract the bit we want...
  return (value >> shift) & 1;  //Shift the bit we want to the right most, and then return
}


void setPercentage(byte value) {
  //reset the values and stop the interrupt routine...
  noInterrupts();
  stepindex=0;
  oncounter=0;
  calculatedpercentage=0;
  millisecondsfor100ZC=0;
  lastinterruptmillis=0;
  interruptcounter=0;        
  Serial.print(F("Set value ")); Serial.print(percentage); Serial.println('%');
  interrupts();
}  

